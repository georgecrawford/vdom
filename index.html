<html>
	<head>
		<script src='./build/main.js'></script>
	</head>
	<body>
		<h1>Virtual DOM</h1>
		<button style='font-size: 20px; color: red;'>Click me!</button>
		<section>
			<h2>My subheading 1</h2>
			<p>Manual DOM manipulation is messy and keeping track of the previous DOM state is hard. A solution to this problem is to write your code as if you were recreating the entire DOM whenever state changes. Of course, if you actually recreated the entire DOM every time your application state changed, your app would be very slow and your input fields would lose focus.</p>
		</section>
		<section>
			<h2>My subheading 2</h2>
			<p>Manual DOM manipulation is messy and keeping track of the previous DOM state is hard. A solution to this problem is to write your code as if you were recreating the entire DOM whenever state changes. Of course, if you actually recreated the entire DOM every time your application state changed, your app would be very slow and your input fields would lose focus.</p>
		</section>
		<section>
			<h2>My subheading 3</h2>
			<p>Manual DOM manipulation is messy and keeping track of the previous DOM state is hard. A solution to this problem is to write your code as if you were recreating the entire DOM whenever state changes. Of course, if you actually recreated the entire DOM every time your application state changed, your app would be very slow and your input fields would lose focus.</p>
		</section>
		<h2>Useful links</h2>
		<ul>
			<li><a href="https://github.com/stevenvachon/handlebars-virtual-dom">Handlebars => vdom compiler</a></li>
			<li><a href="https://github.com/Raynos/main-loop/">Batch virtual DOM changes. Update the virtual tree at most once per request animation frame.</a></li>
			<li><a href="https://github.com/Matt-Esch/virtual-dom/wiki">Other links</a></li>
		</ul>
	</body>
</html>